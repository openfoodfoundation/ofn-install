#------------------
# Precompile assets

# Commands are wrapped in "bash -lc" so that ruby can be initialised using rbenv

# TODO make precompile conditional to speed things up.
- name: precompile assets
  command: bash -lc "bundle exec rake assets:precompile:primary RAILS_GROUPS=assets RAILS_ENV={{ rails_env }}" chdir="{{ current_path }}"
  notify: precompile nondigest assets

- name: precompile nondigest assets
  command: bash -lc "bundle exec rake assets:precompile:nondigest RAILS_GROUPS=assets RAILS_ENV={{ rails_env }}" chdir="{{ current_path }}"



- name: restart delayed job workers
  command:  bash -lc "./script/delayed_job -i 0 stop RAILS_ENV={{ rails_env }}" chdir="{{ current_path }}"


- name: restart unicorn
  command: psql -h {{ db_host }} -U {{ db_user }} -d {{ db }} -c "SELECT true FROM pg_tables WHERE tablename = 'order_cycles';"
  register: table_exists
  ignore_errors: yes
  become: yes
  become_user: "{{ unicorn_user }}"
  notify:
    - restart unicorn step 2
    - restart nginx

#TODO make sure both of these things run as one handler.
- name: restart unicorn step 2
  systemd:
    name: unicorn_{{ app }}
    state: restarted
    user: yes
  become: yes
  become_user: "{{ unicorn_user }}"
  when: table_exists.stderr.find('does not exist') == -1
  environment:
    XDG_RUNTIME_DIR: "/run/user/{{unicorn_user_uid.stdout}}"
  # If unicorn isn't actually started yet we probably need this:
  notify: start unicorn

- name: start unicorn
  systemd:
    name: unicorn_{{ app }}
    state: started
    user: yes
  become: yes
  become_user: "{{ unicorn_user }}"
  environment:
    XDG_RUNTIME_DIR: "/run/user/{{unicorn_user_uid.stdout}}"

- name: restart nginx
  service:
    name: nginx
    state: started
  become: yes

